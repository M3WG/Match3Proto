<!DOCTYPE html>
<html>
  <head>
    <title>m3-prototype</title>

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, user-scalable=0" />

    <link href="./css/main.css" rel="stylesheet" type="text/css" />
    <link href="./css/app.css" rel="stylesheet" />
    <link href="./css/keyframes.css" rel="stylesheet" />
    <link href="./css/utility.css" rel="stylesheet" />
    <link href="./css/component/cell.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/gameStatus.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/map.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/minimap.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/picker.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/scoreboard.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/tilePicker.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/tilePickerOption.css" rel="stylesheet" type="text/css" />

    <!--<script src="./lib/.js"></script>-->

    <script src="./js/main.js"></script>

    <!--<script src="./js/utility/.js"></script>-->
    <script src="./js/utility/array.js"></script>
    <script src="./js/utility/fn.js"></script>
    <script src="./js/utility/matrix.js"></script>
    <script src="./js/utility/pubsub.js"></script>

    <script src="./js/m3.js"></script>

    <!--<script src="./js/m3/app/.js"></script>-->
    <script src="./js/m3/app.js"></script>

    <!--<script src="./js/m3/component/.js"></script>-->
    <script src="./js/m3/component/base.js"></script>
    <script src="./js/m3/component/cell.js"></script>
    <script src="./js/m3/component/gameStatus.js"></script>
    <script src="./js/m3/component/map.js"></script>
    <script src="./js/m3/component/minimap.js"></script>
    <script src="./js/m3/component/picker.js"></script>
    <script src="./js/m3/component/scoreboard.js"></script>
    <script src="./js/m3/component/scoreboardPlayer.js"></script>
    <script src="./js/m3/component/tilePicker.js"></script>
    <script src="./js/m3/component/tilePickerOption.js"></script>

    <!--<script src="./js/m3/config/.js"></script>-->
    <script src="./js/m3/config/claimTypes.js"></script>
    <script src="./js/m3/config/tiles.js"></script>

    <!--<script src="./js/m3/model/.js"></script>-->
    <script src="./js/m3/model/base.js"></script>
    <script src="./js/m3/model/action.js"></script>
    <script src="./js/m3/model/bank.js"></script>
    <script src="./js/m3/model/cell.js"></script>
    <script src="./js/m3/model/claim.js"></script>
    <script src="./js/m3/model/claimType.js"></script>
    <script src="./js/m3/model/game.js"></script>
    <script src="./js/m3/model/hand.js"></script>
    <script src="./js/m3/model/map.js"></script>
    <script src="./js/m3/model/mapSlice.js"></script>
    <script src="./js/m3/model/path.js"></script>
    <script src="./js/m3/model/player.js"></script>
    <script src="./js/m3/model/prefab.js"></script>
    <script src="./js/m3/model/round.js"></script>
    <script src="./js/m3/model/tile.js"></script>
    <script src="./js/m3/model/turn.js"></script>
    <script src="./js/m3/model/user.js"></script>

    <!--<script src="./js/m3/utility/.js"></script>-->
    <script src="./js/m3/utility/action.js"></script>
    <script src="./js/m3/utility/claim.js"></script>
    <script src="./js/m3/utility/crawler.js"></script>
    <script src="./js/m3/utility/map.js"></script>
    <script src="./js/m3/utility/match.js"></script>
    <script src="./js/m3/utility/adjacency.js"></script>
  </head>
  <body>

    <style>
      .m3-a-map {
        position: relative;
        z-index: 1;
      }

      .m3-a-ui {
        height: 100%;
        left: 0;
        position: fixed;
        pointer-events: none;
        top: 0;
        width: 100%;
        z-index: 2;
      }

      .m3-a-gameStatus {
        filter: drop-shadow(0 0 2em #000000);
        left: 0;
        position: absolute;
        top: 0;
        width: 100%;
      }

      .m3-a-minimap {
        bottom: 3em;
        left: 0;
        pointer-events: none;
        position: absolute;
      }

      .m3-a-scoreboard {
        left: 0;
        position: absolute;
        top: 0;
      }

      .m3-a-tilePicker {
        bottom: 0;
        filter: drop-shadow(0 0 2em #000000);
        left: 0;
        position: absolute;
        width: 100%;
      }
    </style>

    <div class="m3-a-map"></div>
    <div class="m3-a-ui">
      <div class="m3-a-gameStatus"></div>
      <div class="m3-a-scoreboard"></div>
      <div class="m3-a-tilePicker"></div>
      <div class="m3-a-minimap"></div>
    </div>

    <script>
      // Create players
      const playerColors = [
        '#FF0000',
        '#0000FF',
        '#FFFF00',
        '#FF00FF',
      ];

      const playerCount = Math.min(parseInt(prompt('How many players?')) || 1, 4)
      const players = Array(playerCount).fill().map((_, index) =>
        m3.model.player.create({
          color: playerColors[index],
          name: 'Player ' + (index + 1),
        })
      )

      const sharedFog = false

      const claimStore = []
      const playerViews = new Map(
        players.map((player) => [player, {}])
      )

      const startingInventory = [
        [1, Infinity],
        [3, Infinity],
        [4, Infinity],
        [5, Infinity],
        [2, Infinity],
        [6, 0],
        [7, 1],
        [0, 0],
      ]
      const playerInventories = new Map(
        players.map((player) => [player, new Map(startingInventory)])
      )

      // Create game
      const map = m3.model.map.create({
        height: 100,
        width: 100,
      })

      const game = m3.model.game.create({
        map,
        player: players,
      })

      game.createRound().createTurn({
        player: game.getPlayer(0),
      })

      // Map generation
      m3.utility.map.randomize(map)

      const createStartLocation = (player, x, y) => {
        const cell = map.getCell(x, y)

        const claim = m3.model.claim.create({
          cell: [cell],
          player,
          type: m3.model.claimType.get(6),
        })

        cell.setTile(7).setClaim(claim)

        claimStore.push(claim)

        return claim
      }

      const startLocationCoordinates = [
        {x: 40, y: 40},
        {x: 60, y: 40},
        {x: 60, y: 60},
        {x: 40, y: 60},
      ]

      const startLocations = players.map((player, index) => {
        const {x, y} = startLocationCoordinates[index]
        return createStartLocation(player, x, y)
      })

      // Create components
      const mapComponent = m3.component.map.create({
        model: map,
      }, document.querySelector('.m3-a-map')).setId('map').attach()

      mapComponent.getCells().forEach((component) => {
        component.on('click', () => doAction(component))
      })

      // TODO: Enable when complete
      /*
      const minimapComponent = m3.component.minimap.create({
        model: map,
      }, document.querySelector('.m3-a-minimap')).attach()
      */

      const scoreboardComponent = m3.component.scoreboard.create({
        player: players,
      }, document.querySelector('.m3-a-scoreboard')).attach()

      const gameStatusComponent = m3.component.gameStatus.create({
        model: game,
      }, document.querySelector('.m3-a-gameStatus')).attach()

      const tilePickerOptions = m3.model.tile.getAll().filter((tile) =>
        tile.config.picker && tile.config.picker.active
      ).sort((a, b) =>
        a.config.picker.position - b.config.picker.position
      ).map((tile) => ({
        tile,
      }))

      const tilePickerComponent = m3.component.tilePicker.create({
        option: tilePickerOptions,
      }, document.querySelector('.m3-a-tilePicker')).attach()

      // Initialize player views
      startLocations.forEach((claim) => {
        const cell = claim.getCells()[0],
          cellComponent = mapComponent.getCell(cell.getX(), cell.getY()),
          player = claim.player,
          rect = cellComponent.getBoundingClientRect(),
          x = cellComponent._rootElement.offsetLeft - vw(50) + (0.5 * rect.width),
          y = cellComponent._rootElement.offsetTop - vh(50) + (0.5 * rect.height)

        const playerView = playerViews.get(player)

        playerView.tile = 0
        playerView.x = x
        playerView.y = y
      })

      // Set up first player view
      transitionPlayerView(players[0])

      if (sharedFog) {
        claimStore.forEach((claim) => drawClaimFog(claim, false))
      }

      // Action logic
      function doAction(component) {
        const cell = component.getModel(),
          round = game.getCurrentRound(),
          tile = tilePickerComponent.getValue(),
          turn = round.getCurrentTurn(),
          turnPlayer = turn.player

        const options = {
          cell,
          tile,
        }

        try {
          if (cell.getFog() && !tile.isPlaceableInFog()) {
            throw new Error('Tile type cannot be placed in fog')
          }

          if (getPlayerInventory(turnPlayer, tile) <= 0) {
            throw new Error('Inventory is zero')
          }

          m3.utility.action.validate(options)
        } catch (e) {
          console.error(e)
          alert('Invalid action: ' + e.message)
          return
        }

        modifyPlayerInventory(turnPlayer, tile, -1)
        modifyPlayerInventory(turnPlayer, cell.tile, +1)
        cell.setTile(tile)

        const match = m3.utility.match(options)

        if (match) {
          const claim = m3.model.claim.create({
            player: turnPlayer,
            ...match,
          })

          claimStore.push(claim)
          turnPlayer.incrementScore(claim.type.getScore() * claim.getSize())
          drawClaimFog(claim, false)
        }

        const action = turn.createAction(options),
          isTurnEnd = turn.getActionCount() >= 4

        if (isTurnEnd) {
          const isRoundEnd = isTurnEnd && round.getTurnCount() >= game.getPlayerCount()
          const isGameEnd = isRoundEnd && m3.utility.map.getPercentClaimed(map) > (0.125 * playerCount)

          if (isGameEnd) {
            handleGameEnd()
          } else if (isRoundEnd) {
            const firstPlayer = game.getPlayer(0)

            game.createRound().createTurn({
              player: firstPlayer,
            })

            updateTurnScore(turnPlayer)
            updateRoundScores()
            transitionPlayerView(firstPlayer, turnPlayer)
          } else {
            const nextPlayer = game.getPlayer(round.getTurnCount())

            round.createTurn({
              player: nextPlayer,
            })

            updateTurnScore(turnPlayer)
            transitionPlayerView(nextPlayer, turnPlayer)
          }
        } else {
          updateTilePickerInventory(turnPlayer)
        }

        gameStatusComponent.render()
      }

      // Utility functions
      function drawClaimFog(claim, state) {
        const drawCellFog = (cell) => cell.setFog(state)

        return claim.getFogShape().forEach(drawCellFog)
      }

      function drawPlayerFog(player, state) {
        const filterInPlayer = (claim) => claim.player == player
        const drawFog = (claim) => drawClaimFog(claim, state)

        claimStore.filter(filterInPlayer)
          .forEach(drawFog)
      }

      function getPlayerInventory(player, tile) {
        const inventory = playerInventories.get(player),
          tileId = tile.getId()

        return inventory.get(tileId) || 0
      }

      function handleGameEnd() {
        mapComponent.getCells().forEach((cell) => cell.off('click'))
        map.getCells().forEach((cell) => cell.setFog(false))

        alert('Game Over');
      }

      function modifyPlayerInventory(player, tile, amount) {
        const inventory = playerInventories.get(player),
          tileId = tile.getId(),
          value = inventory.get(tileId)

        inventory.set(tileId, value + amount || 0)
      }

      function transitionPlayerView(nextPlayer, currentPlayer) {
        updateTilePickerInventory(nextPlayer)

        if (nextPlayer === currentPlayer) {
          return
        }

        const currentView = playerViews.get(currentPlayer),
          nextView = playerViews.get(nextPlayer)

        if (currentView) {
          currentView.tile = tilePickerComponent.getSelectedIndex()
          currentView.x = window.scrollX
          currentView.y = window.scrollY

          alert('Up next: ' + nextPlayer.getName())
        }

        tilePickerComponent.setSelectedIndex(nextView.tile)

        if (!sharedFog) {
          if (currentPlayer) {
            drawPlayerFog(currentPlayer, true)
          }
          drawPlayerFog(nextPlayer, false)
        }

        window.scrollTo({
          left: nextView.x,
          top: nextView.y,
          behavior: 'smooth',
        })
      }

      function updateRoundScores() {
        // TODO
      }

      function updateTilePickerInventory(player) {
        const inventory = playerInventories.get(player)

        tilePickerComponent.getOptions().forEach((option) => {
          const tile = option.getValue(),
            tileId = tile.getId(),
            value = inventory.get(tileId)

          option.setInventory(value)
        })
      }

      function updateTurnScore(player) {
        const isCity = (claim) => claim.type.getId() === 1,
          isWatchtower = (claim) => claim.type.getId() === 6,
          isPlayerOwned = (claim) => claim.player === player,
          isPlayerOwnedCity = (claim) => isPlayerOwned(claim) && isCity(claim),
          isPlayerOwnedWatchtower = (claim) => isPlayerOwned(claim) && isWatchtower(claim)

        player.incrementScore(
          claimStore.filter(isPlayerOwnedCity).reduce((score, city) => {
            const adjacencies = m3.utility.adjacency.getClaimsGreedy(city)
            return score + (adjacencies.length - 1)
          }, 0)
          +
          claimStore.filter(isPlayerOwnedWatchtower).reduce((score, watchtower) => {
            const adjacencies = m3.utility.adjacency.getClaimsGreedy(watchtower)
            return score + ((adjacencies.length - 1) * 0.25)
          }, 0)
        )
      }

      function vh(value) {
        return window.innerHeight / 100 * value
      }

      function vw(value) {
        return window.innerWidth / 100 * value
      }

      /*
      XXX: Accidental commit, keep for now
      Adjacency:
      each round:
      for each city claim, get adjacent claims
        when claims are adjacent, they go into an array of their adjacent claims
        each claim appears in only one array, even if it's just by itself
        if claim already belongs in an array, skip checks and use reference to that array
        cities are adjacent if they appear
        eventually adjacency checks will include all water

      claims have "Centers" which is the midpoint between all cells--becomes important with greedy matching
      score per turn: each bucket of adjacencies, for each city claim, collect score from all other adjacent claims divided by a distance modifier multiplied by type modifier (and modifier based on city size)

      Greedy matching:
      Eliminate shape checks
      Instead crawl through for at least four adjacent cells of same type
      Additional cells beyond 4 become part of the claim
      */
    </script>
  </body>
</html>
