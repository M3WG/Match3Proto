<!DOCTYPE html>
<html>
  <head>
    <title>m3-prototype</title>

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, user-scalable=0" />

    <link href="./css/main.css" rel="stylesheet" type="text/css" />
    <link href="./css/app.css" rel="stylesheet" />
    <link href="./css/keyframes.css" rel="stylesheet" />
    <link href="./css/utility.css" rel="stylesheet" />
    <link href="./css/component/cell.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/gameStatus.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/map.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/minimap.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/picker.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/scoreboard.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/tilePicker.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/tilePickerOption.css" rel="stylesheet" type="text/css" />

    <!--<script src="./lib/.js"></script>-->

    <script src="./js/main.js"></script>

    <!--<script src="./js/utility/.js"></script>-->
    <script src="./js/utility/array.js"></script>
    <script src="./js/utility/fn.js"></script>
    <script src="./js/utility/matrix.js"></script>
    <script src="./js/utility/pubsub.js"></script>

    <script src="./js/m3.js"></script>

    <!--<script src="./js/m3/app/.js"></script>-->
    <script src="./js/m3/app.js"></script>

    <!--<script src="./js/m3/component/.js"></script>-->
    <script src="./js/m3/component/base.js"></script>
    <script src="./js/m3/component/cell.js"></script>
    <script src="./js/m3/component/gameStatus.js"></script>
    <script src="./js/m3/component/map.js"></script>
    <script src="./js/m3/component/minimap.js"></script>
    <script src="./js/m3/component/picker.js"></script>
    <script src="./js/m3/component/scoreboard.js"></script>
    <script src="./js/m3/component/scoreboardPlayer.js"></script>
    <script src="./js/m3/component/tilePicker.js"></script>
    <script src="./js/m3/component/tilePickerOption.js"></script>

    <!--<script src="./js/m3/config/.js"></script>-->
    <script src="./js/m3/config/claimTypes.js"></script>
    <script src="./js/m3/config/tiles.js"></script>

    <!--<script src="./js/m3/model/.js"></script>-->
    <script src="./js/m3/model/base.js"></script>
    <script src="./js/m3/model/action.js"></script>
    <script src="./js/m3/model/bank.js"></script>
    <script src="./js/m3/model/cell.js"></script>
    <script src="./js/m3/model/claim.js"></script>
    <script src="./js/m3/model/claimType.js"></script>
    <script src="./js/m3/model/game.js"></script>
    <script src="./js/m3/model/hand.js"></script>
    <script src="./js/m3/model/map.js"></script>
    <script src="./js/m3/model/mapSlice.js"></script>
    <script src="./js/m3/model/path.js"></script>
    <script src="./js/m3/model/player.js"></script>
    <script src="./js/m3/model/prefab.js"></script>
    <script src="./js/m3/model/round.js"></script>
    <script src="./js/m3/model/tile.js"></script>
    <script src="./js/m3/model/turn.js"></script>
    <script src="./js/m3/model/user.js"></script>

    <!--<script src="./js/m3/utility/.js"></script>-->
    <script src="./js/m3/utility/action.js"></script>
    <script src="./js/m3/utility/claim.js"></script>
    <script src="./js/m3/utility/crawler.js"></script>
    <script src="./js/m3/utility/map.js"></script>
    <script src="./js/m3/utility/match.js"></script>
    <script src="./js/m3/utility/path.js"></script>
    <script src="./js/m3/utility/adjacency.js"></script>
  </head>
  <body>

    <style>
      .m3-a-map {
        position: relative;
        z-index: 1;
      }

      .m3-a-ui {
        height: 100%;
        left: 0;
        position: fixed;
        pointer-events: none;
        top: 0;
        width: 100%;
        z-index: 2;
      }

      .m3-a-gameStatus {
        filter: drop-shadow(0 0 2em #000000);
        left: 0;
        position: absolute;
        top: 0;
        width: 100%;
      }

      .m3-a-minimap {
        bottom: 3em;
        left: 0;
        pointer-events: none;
        position: absolute;
      }

      .m3-a-scoreboard {
        left: 0;
        position: absolute;
        top: 0;
      }

      .m3-a-tilePicker {
        bottom: 0;
        filter: drop-shadow(0 0 2em #000000);
        left: 0;
        position: absolute;
        width: 100%;
      }
    </style>

    <div class="m3-a-map"></div>
    <div class="m3-a-ui">
      <div class="m3-a-gameStatus"></div>
      <div class="m3-a-scoreboard"></div>
      <div class="m3-a-tilePicker"></div>
      <div class="m3-a-minimap"></div>
    </div>

    <script>
      // Create players
      const playerColors = [
        '#FF0000',
        '#0000FF',
        '#FFFF00',
        '#FF00FF',
      ]

      const playerCount = Math.min(parseInt(prompt('How many players?')) || 1, 4)
      const players = Array(playerCount).fill().map((_, index) =>
        m3.model.player.create({
          color: playerColors[index],
          name: 'Player ' + (index + 1),
        })
      )

      const sharedFog = false

      const claimStore = []
      const playerViews = new Map(
        players.map((player) => [player, {}])
      )

      const startingInventory = [
        [1, Infinity],
        [3, Infinity],
        [4, Infinity],
        [5, Infinity],
        [2, Infinity],
        [6, 0],
        [7, 1],
        [0, 0],
      ]
      const playerInventories = new Map(
        players.map((player) => [player, new Map(startingInventory)])
      )

      // Create game
      const map = m3.model.map.create({
        height: 100,
        width: 100,
      })

      const game = m3.model.game.create({
        map,
        player: players,
      })

      game.createRound().createTurn({
        player: game.getPlayer(0),
      })

      // Map generation
      m3.utility.map.randomize(map)

      const createStartLocation = (player, x, y) => {
        const cell = map.getCell(x, y)

        const claim = m3.model.claim.create({
          cell: [cell],
          player,
          type: m3.model.claimType.get(6),
        })

        cell.setTile(7).setClaim(claim)

        claimStore.push(claim)

        return claim
      }

      const startLocationCoordinates = [
        {x: 40, y: 40},
        {x: 60, y: 40},
        {x: 60, y: 60},
        {x: 40, y: 60},
      ]

      const startLocations = players.map((player, index) => {
        const {x, y} = startLocationCoordinates[index]
        return createStartLocation(player, x, y)
      })

      // Create components
      const mapComponent = m3.component.map.create({
        model: map,
      }, document.querySelector('.m3-a-map')).setId('map').attach()

      mapComponent.getCells().forEach((component) => {
        component.on('click', () => doAction(component))
      })

      // TODO: Enable when complete
      /*
      const minimapComponent = m3.component.minimap.create({
        model: map,
      }, document.querySelector('.m3-a-minimap')).attach()
      */

      const scoreboardComponent = m3.component.scoreboard.create({
        player: players,
      }, document.querySelector('.m3-a-scoreboard')).attach()

      const gameStatusComponent = m3.component.gameStatus.create({
        model: game,
      }, document.querySelector('.m3-a-gameStatus')).attach()

      const tilePickerOptions = m3.model.tile.getAll().filter((tile) =>
        tile.config.picker && tile.config.picker.active
      ).sort((a, b) =>
        a.config.picker.position - b.config.picker.position
      ).map((tile) => ({
        tile,
      }))

      const tilePickerComponent = m3.component.tilePicker.create({
        option: tilePickerOptions,
      }, document.querySelector('.m3-a-tilePicker')).attach()

      // Initialize player views
      startLocations.forEach((claim) => {
        const cell = claim.getCells()[0],
          cellComponent = mapComponent.getCell(cell.getX(), cell.getY()),
          player = claim.player,
          rect = cellComponent.getBoundingClientRect(),
          x = cellComponent._rootElement.offsetLeft - vw(50) + (0.5 * rect.width),
          y = cellComponent._rootElement.offsetTop - vh(50) + (0.5 * rect.height)

        const playerView = playerViews.get(player)

        playerView.tile = 0
        playerView.x = x
        playerView.y = y
      })

      // Set up first player view
      transitionPlayerView(players[0])

      if (sharedFog) {
        claimStore.forEach((claim) => drawClaimFog(claim, false))
      }

      // Action logic
      function doAction(component) {
        const cell = component.getModel(),
          round = game.getCurrentRound(),
          tile = tilePickerComponent.getValue(),
          turn = round.getCurrentTurn(),
          turnPlayer = turn.player

        const options = {
          cell,
          tile,
        }

        try {
          if (cell.getFog() && !tile.isPlaceableInFog()) {
            throw new Error('Tile type cannot be placed in fog')
          }

          if (getPlayerInventory(turnPlayer, tile) <= 0) {
            throw new Error('Inventory is zero')
          }

          m3.utility.action.validate(options)
        } catch (e) {
          console.error(e)
          alert('Invalid action: ' + e.message)
          return
        }

        modifyPlayerInventory(turnPlayer, tile, -1)
        modifyPlayerInventory(turnPlayer, cell.tile, +1)
        cell.setTile(tile)

        const match = m3.utility.match(options, turnPlayer)

        if (match) {
          handleMatch(match, turnPlayer)
        }

        const action = turn.createAction(options),
          isTurnEnd = turn.getActionCount() >= 4

        if (isTurnEnd) {
          const isRoundEnd = isTurnEnd && round.getTurnCount() >= game.getPlayerCount()
          const isGameEnd = isRoundEnd && m3.utility.map.getPercentClaimed(map) > (0.125 * playerCount)

          if (isGameEnd) {
            handleGameEnd()
          } else if (isRoundEnd) {
            const firstPlayer = game.getPlayer(0)

            game.createRound().createTurn({
              player: firstPlayer,
            })

            updateTurnScore(turnPlayer)
            updateRoundScores()
            transitionPlayerView(firstPlayer, turnPlayer)
          } else {
            const nextPlayer = game.getPlayer(round.getTurnCount())

            round.createTurn({
              player: nextPlayer,
            })

            updateTurnScore(turnPlayer)
            transitionPlayerView(nextPlayer, turnPlayer)
          }
        } else {
          updateTilePickerInventory(turnPlayer)
        }

        gameStatusComponent.render()
      }

      // Utility functions
      function drawClaimFog(claim, state) {
        const drawCellFog = (cell) => cell.setFog(state)

        return claim.getFogShape().forEach(drawCellFog)
      }

      function drawPlayerFog(player, state) {
        const filterInPlayer = (claim) => claim.player == player
        const drawFog = (claim) => drawClaimFog(claim, state)

        claimStore.filter(filterInPlayer)
          .forEach(drawFog)
      }

      function getPlayerInventory(player, tile) {
        const inventory = playerInventories.get(player),
          tileId = tile.getId()

        return inventory.get(tileId) || 0
      }

      function handleGameEnd() {
        mapComponent.getCells().forEach((cell) => cell.off('click'))
        map.getCells().forEach((cell) => cell.setFog(false))

        alert('Game Over')
      }

      function handleMatch(match, player) {
        const cells = match.cell,
          unclaimedCells = cells.filter((cell) => !cell.claim)

        cells.reduce((claims, cell) => {
          const claim = cell.claim

          if (claim && !claims.includes(claim)) {
            claims.push(claim)
          }

          return claims
        }, []).forEach((claim) => {
          claim.destruct()
          claimStore.splice(claimStore.indexOf(claim), 1)
        })

        const claim = m3.model.claim.create({
          player,
          ...match,
        })

        claimStore.push(claim)

        const score = claim.type.getScore() * unclaimedCells.length

        player.incrementScore(score)
        logScore(score, claim)

        drawClaimFog(claim, false)
      }

      function logScore(score, ...claims) {
        console.log('SCORE:', score, ...claims.map((claim) => {
          const cell = claim.getCells()[0],
            x = cell.getX(),
            y = cell.getY()

          return mapComponent.getCell(x, y)._rootElement
        }), claims)
      }

      function modifyPlayerInventory(player, tile, amount) {
        const inventory = playerInventories.get(player),
          tileId = tile.getId(),
          value = inventory.get(tileId)

        inventory.set(tileId, value + amount || 0)
      }

      function transitionPlayerView(nextPlayer, currentPlayer) {
        console.log('=== ROUND ' + game.getRoundCount() + ' - ' + nextPlayer.getName() + ' ===')

        updateTilePickerInventory(nextPlayer)

        if (nextPlayer === currentPlayer) {
          return
        }

        const currentView = playerViews.get(currentPlayer),
          nextView = playerViews.get(nextPlayer)

        if (currentView) {
          currentView.tile = tilePickerComponent.getSelectedIndex()
          currentView.x = window.scrollX
          currentView.y = window.scrollY

          alert('Up next: ' + nextPlayer.getName())
        }

        tilePickerComponent.setSelectedIndex(nextView.tile)

        if (!sharedFog) {
          if (currentPlayer) {
            drawPlayerFog(currentPlayer, true)
          }
          drawPlayerFog(nextPlayer, false)
        }

        window.scrollTo({
          left: nextView.x,
          top: nextView.y,
          behavior: 'smooth',
        })
      }

      function updateRoundScores() {
        // TODO
      }

      function updateTilePickerInventory(player) {
        const inventory = playerInventories.get(player)

        tilePickerComponent.getOptions().forEach((option) => {
          const tile = option.getValue(),
            tileId = tile.getId(),
            value = inventory.get(tileId)

          option.setInventory(value)
        })
      }

      function updateTurnScore(player) {
        // TODO: Change allowedClaims/isAllowedClaim to use a configuration value, e.g. claim.isEconomy()
        const allowedClaims = [1, 6],
          isAllowedClaim = (claim) => allowedClaims.includes(claim.type.getId()),
          isPlayer = (test) => test === player,
          isPlayerOwned = (claim) => isPlayer(claim.player)

        const calculateClaimScore = (claim) => {
          const adjacencies = m3.utility.adjacency.getClaimsGreedy(claim),
            isClaim = (test) => test === claim

          const calculateAdjacencyScore = (adjacency) => {
            const claimMultiplier = adjacency.type.getMultiplier(),
              ownerMultiplier = isPlayer(adjacency.player) ? 1 : 0.5,
              sizeMultiplier = Math.min(adjacency.getSize(), claim.getSize())

            const score = claimMultiplier * ownerMultiplier * sizeMultiplier
            logScore(score, claim, adjacency)

            return score
          }

          return adjacencies.reduce((score, adjacency) => {
            if (isClaim(adjacency)) {
              return score
            }

            return score + calculateAdjacencyScore(adjacency)
          }, 0)
        }

        player.incrementScore(
          claimStore.reduce((score, claim) => {
            if (!isPlayerOwned(claim) || !isAllowedClaim(claim)) {
              return score
            }

            return score + calculateClaimScore(claim)
          }, 0)
        )
      }

      function vh(value) {
        return window.innerHeight / 100 * value
      }

      function vw(value) {
        return window.innerWidth / 100 * value
      }
    </script>
  </body>
</html>
