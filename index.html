<!DOCTYPE html>
<html>
  <head>
    <title>m3-prototype</title>

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, user-scalable=0" />

    <link href="./css/main.css" rel="stylesheet" type="text/css" />
    <link href="./css/app.css" rel="stylesheet" />
    <link href="./css/keyframes.css" rel="stylesheet" />
    <link href="./css/utility.css" rel="stylesheet" />
    <link href="./css/component/cell.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/gameStatus.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/map.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/minimap.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/picker.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/scoreboard.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/tilePicker.css" rel="stylesheet" type="text/css" />
    <link href="./css/component/tilePickerOption.css" rel="stylesheet" type="text/css" />

    <!--<script src="./lib/.js"></script>-->

    <script src="./js/main.js"></script>

    <!--<script src="./js/utility/.js"></script>-->
    <script src="./js/utility/array.js"></script>
    <script src="./js/utility/fn.js"></script>
    <script src="./js/utility/matrix.js"></script>
    <script src="./js/utility/pubsub.js"></script>

    <script src="./js/m3.js"></script>

    <!--<script src="./js/m3/app/.js"></script>-->
    <script src="./js/m3/app.js"></script>

    <!--<script src="./js/m3/component/.js"></script>-->
    <script src="./js/m3/component/base.js"></script>
    <script src="./js/m3/component/cell.js"></script>
    <script src="./js/m3/component/gameStatus.js"></script>
    <script src="./js/m3/component/map.js"></script>
    <script src="./js/m3/component/minimap.js"></script>
    <script src="./js/m3/component/picker.js"></script>
    <script src="./js/m3/component/scoreboard.js"></script>
    <script src="./js/m3/component/scoreboardPlayer.js"></script>
    <script src="./js/m3/component/tilePicker.js"></script>
    <script src="./js/m3/component/tilePickerOption.js"></script>

    <!--<script src="./js/m3/config/.js"></script>-->
    <script src="./js/m3/config/claimTypes.js"></script>
    <script src="./js/m3/config/shapes.js"></script>
    <script src="./js/m3/config/tiles.js"></script>

    <!--<script src="./js/m3/model/.js"></script>-->
    <script src="./js/m3/model/base.js"></script>
    <script src="./js/m3/model/action.js"></script>
    <script src="./js/m3/model/bank.js"></script>
    <script src="./js/m3/model/cell.js"></script>
    <script src="./js/m3/model/claim.js"></script>
    <script src="./js/m3/model/claimType.js"></script>
    <script src="./js/m3/model/game.js"></script>
    <script src="./js/m3/model/hand.js"></script>
    <script src="./js/m3/model/map.js"></script>
    <script src="./js/m3/model/mapSlice.js"></script>
    <script src="./js/m3/model/path.js"></script>
    <script src="./js/m3/model/player.js"></script>
    <script src="./js/m3/model/prefab.js"></script>
    <script src="./js/m3/model/round.js"></script>
    <script src="./js/m3/model/tile.js"></script>
    <script src="./js/m3/model/turn.js"></script>
    <script src="./js/m3/model/user.js"></script>

    <!--<script src="./js/m3/utility/.js"></script>-->
    <script src="./js/m3/utility/action.js"></script>
    <script src="./js/m3/utility/claim.js"></script>
    <script src="./js/m3/utility/crawler.js"></script>
    <script src="./js/m3/utility/map.js"></script>
    <script src="./js/m3/utility/match.js"></script>
  </head>
  <body>

    <style>
      .m3-a-map {
        position: relative;
        z-index: 1;
      }

      .m3-a-ui {
        height: 100%;
        left: 0;
        position: fixed;
        pointer-events: none;
        top: 0;
        width: 100%;
        z-index: 2;
      }

      .m3-a-gameStatus {
        filter: drop-shadow(0 0 2em #000000);
        left: 0;
        position: absolute;
        top: 0;
        width: 100%;
      }

      .m3-a-minimap {
        bottom: 3em;
        left: 0;
        pointer-events: none;
        position: absolute;
      }

      .m3-a-scoreboard {
        left: 0;
        position: absolute;
        top: 0;
      }

      .m3-a-tilePicker {
        bottom: 0;
        filter: drop-shadow(0 0 2em #000000);
        left: 0;
        position: absolute;
        width: 100%;
      }
    </style>

    <div class="m3-a-map"></div>
    <div class="m3-a-ui">
      <div class="m3-a-gameStatus"></div>
      <div class="m3-a-scoreboard"></div>
      <div class="m3-a-tilePicker"></div>
      <div class="m3-a-minimap"></div>
    </div>

    <script>
      // Create players
      const playerColors = [
        '#FF0000',
        '#0000FF',
        '#FFFF00',
        '#FF00FF',
      ];

      const playerCount = Math.min(parseInt(prompt('How many players?')) || 1, 4)
      const players = Array(playerCount).fill().map((_, index) =>
        m3.model.player.create({
          color: playerColors[index],
          name: 'Player ' + (index + 1),
        })
      )

      const claimStore = []
      const playerViews = new Map(
        players.map((player) => [player, {}])
      )

      const startingInventory = [
        [1, Infinity],
        [3, Infinity],
        [4, Infinity],
        [5, Infinity],
        [2, Infinity],
        [6, 4],
        [7, 4],
      ]
      const playerInventories = new Map(
        players.map((player) => [player, new Map(startingInventory)])
      )

      // Create game
      const map = m3.model.map.create({
        height: 100,
        width: 100,
      })

      const game = m3.model.game.create({
        map,
        player: players,
      })

      game.createRound().createTurn({
        player: game.getPlayer(0),
      })

      // Map generation
      m3.utility.map.randomize(map)

      const createStartLocation = (player, x, y) => {
        const cell = map.getCell(x, y)

        const claim = m3.model.claim.create({
          cell: [cell],
          player,
          type: m3.model.claimType.get(6),
        })

        cell.setTile(7).setClaim(claim)

        claimStore.push(claim)

        return claim
      }

      const startLocationCoordinates = [
        {x: 40, y: 40},
        {x: 60, y: 40},
        {x: 60, y: 60},
        {x: 40, y: 60},
      ]

      const startLocations = players.map((player, index) => {
        const {x, y} = startLocationCoordinates[index]
        return createStartLocation(player, x, y)
      })

      claimStore.forEach((claim) => {
        claim.getFogShape().forEach((cell) => cell.setFog(false))
      })

      // Create components
      const mapComponent = m3.component.map.create({
        model: map,
      }, document.querySelector('.m3-a-map')).setId('map').attach()

      // TODO: Enable when complete
      /*
      const minimapComponent = m3.component.minimap.create({
        model: map,
      }, document.querySelector('.m3-a-minimap')).attach()
      */

      const scoreboardComponent = m3.component.scoreboard.create({
        player: players,
      }, document.querySelector('.m3-a-scoreboard')).attach()

      const gameStatusComponent = m3.component.gameStatus.create({
        model: game,
      }, document.querySelector('.m3-a-gameStatus')).attach()

      const tilePickerOptions = m3.model.tile.getAll().filter((tile) =>
        tile.config.picker && tile.config.picker.active
      ).sort((a, b) =>
        a.config.picker.position - b.config.picker.position
      ).map((tile) => ({
        tile,
      }))

      const tilePickerComponent = m3.component.tilePicker.create({
        option: tilePickerOptions,
      }, document.querySelector('.m3-a-tilePicker')).attach()

      // Click event handlers
      mapComponent.getCells().forEach((component) => {
        component.on('click', () => {
          const cell = component.getModel(),
            round = game.getCurrentRound(),
            tile = tilePickerComponent.getValue(),
            turn = round.getCurrentTurn(),
            turnPlayer = turn.player

          const options = {
            cell,
            tile,
          }

          try {
            if (getPlayerInventory(turnPlayer, tile) <= 0) {
              throw new Error('Inventory is zero')
            }

            m3.utility.action.validate(options)
          } catch (e) {
            console.error(e)
            alert('Invalid action: ' + e.message)
            return
          }

          modifyPlayerInventory(turnPlayer, tile, -1)
          modifyPlayerInventory(turnPlayer, cell.tile, +1)
          cell.setTile(tile)

          const match = m3.utility.match(options)

          if (match) {
            match.player = turnPlayer

            const claim = m3.model.claim.create(match),
              score = claim.type.getScore()

            turn.player.incrementScore(score)

            claim.getFogShape().forEach((cell) => cell.setFog(false))

            claimStore.push(claim)
          }

          const action = turn.createAction(options),
            isTurnEnd = turn.getActionCount() >= 4

          if (isTurnEnd) {
            const isRoundEnd = isTurnEnd && round.getTurnCount() >= game.getPlayerCount()

            if (isRoundEnd) {
              const firstPlayer = game.getPlayer(0)

              // XXX: Goes forever!
              // TODO: Check game end condition
              game.createRound().createTurn({
                player: firstPlayer,
              })

              transitionPlayerView(firstPlayer, turnPlayer)
            } else {
              const nextPlayer = game.getPlayer(round.getTurnCount())

              round.createTurn({
                player: nextPlayer,
              })

              transitionPlayerView(nextPlayer, turnPlayer)
            }
          } else {
            updateTilePickerInventory(turnPlayer)
          }

          gameStatusComponent.render()
        })
      })

      // Initialize player views
      startLocations.forEach((claim) => {
        const cell = claim.getCells()[0],
          cellComponent = mapComponent.getCell(cell.getX(), cell.getY()),
          player = claim.player,
          rect = cellComponent.getBoundingClientRect(),
          x = cellComponent._rootElement.offsetLeft - vw(50) + (0.5 * rect.width),
          y = cellComponent._rootElement.offsetTop - vh(50) + (0.5 * rect.height)

        const playerView = playerViews.get(player)

        playerView.tile = 0
        playerView.x = x
        playerView.y = y
      })

      // Set up first player view
      transitionPlayerView(players[0])

      // Utility functions
      function getPlayerInventory(player, tile) {
        const inventory = playerInventories.get(player),
          tileId = tile.getId()

        return inventory.get(tileId) || 0
      }

      function modifyPlayerInventory(player, tile, amount) {
        const inventory = playerInventories.get(player),
          tileId = tile.getId(),
          value = inventory.get(tileId)

        inventory.set(tileId, value + amount || 0)
      }

      function transitionPlayerView(nextPlayer, currentPlayer) {
        updateTilePickerInventory(nextPlayer)

        if (nextPlayer === currentPlayer) {
          return
        }

        const currentView = playerViews.get(currentPlayer),
          nextView = playerViews.get(nextPlayer)

        if (currentView) {
          currentView.tile = tilePickerComponent.getSelectedIndex()
          currentView.x = window.scrollX
          currentView.y = window.scrollY

          alert('Up next: ' + nextPlayer.getName())
        }

        tilePickerComponent.setSelectedIndex(nextView.tile)

        window.scrollTo({
          left: nextView.x,
          top: nextView.y,
          behavior: 'smooth',
        })
      }

      function updateTilePickerInventory(player) {
        const inventory = playerInventories.get(player)

        tilePickerComponent.getOptions().forEach((option) => {
          const tile = option.getValue(),
            tileId = tile.getId(),
            value = inventory.get(tileId)

          option.setInventory(value)
        })
      }

      function vh(value) {
        return window.innerHeight / 100 * value
      }

      function vw(value) {
        return window.innerWidth / 100 * value
      }
    </script>
  </body>
</html>
